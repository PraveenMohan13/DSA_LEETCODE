
<!-- problem:start -->

# Dynamic Programming on Grid


## LeetCode Practice Flow

________________________________________________________
üß† Concepts Required
‚Ä¢ 2D Arrays
‚Ä¢ Recursion + Memoization
‚Ä¢ Tabulation
‚Ä¢ Space Optimization
‚Ä¢ Path Finding / Counting / Min/Max Costs
________________________________________________________________
üö∂‚Äç‚ôÇÔ∏è Level 1: Basic Grid Traversal (Recursive ‚Üí Memoization ‚Üí Tabulation)
‚Ä¢	Unique Paths (LeetCode 62) - Count paths
‚Ä¢	Unique Paths II (with obstacles) (LeetCode 63) - Count paths
‚Ä¢	Minimum Path Sum (LeetCode 64) - Min cost path
‚Ä¢	Maximum Path Sum in Matrix (LeetCode 2218) - Max path sum
________________________________________________________________
üßó‚Äç‚ôÇÔ∏è Level 2: Grid with Directional Movement
‚Ä¢	Minimum Falling Path Sum (LeetCode 931) - Downward only
‚Ä¢	Minimum Path Cost in Grid (LeetCode 2304) - Directional movement
‚Ä¢	Cherry Pickup II (LeetCode 1463) - Two-agent DP
________________________________________________________________
üß® Level 3: Obstacle-Based / Conditional Paths
‚Ä¢	Dungeon Game (LeetCode 174) - Reverse DP
‚Ä¢	Cherry Pickup I (LeetCode 741) - Collect + return
‚Ä¢	Path with Maximum Gold (LeetCode 1219) - DFS + backtracking
________________________________________________________________
üí£ Level 4: Complex Grids (3D/Space Optimization)
‚Ä¢	Paint House (LeetCode 256) - Row-wise choices
‚Ä¢	Paint House II (LeetCode 265) - Optimized
‚Ä¢	Grid Unique Paths with Diagonal (LeetCode Custom variation) - Extend base logic
________________________________________________________________
üõ†Ô∏è Practice Flow
‚Ä¢ Start with recursion + memoization for small test cases.
‚Ä¢ Convert to tabulation ‚Äì build a dp[i][j] matrix.
‚Ä¢ Optimize to 1D or reduced space if applicable.
‚Ä¢ Use direction arrays if movement is not limited to just right/down.
‚Ä¢ For 2 agents (like Cherry Pickup II), use 3D DP.

<!-- problem:end -->
